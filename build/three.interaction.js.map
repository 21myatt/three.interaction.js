{"version":3,"file":"three.interaction.js","sources":["../src/utils/Raf.js","../src/utils/Utils.js","../src/patch/EventDispatcher.js","../src/patch/Object3D.js","../src/utils/Ticker.js","../src/interaction/InteractionData.js","../src/interaction/InteractionEvent.js","../src/interaction/InteractionTrackingData.js","../src/interaction/InteractionManager.js"],"sourcesContent":["(function() {\n  let lastTime = 0;\n  let vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n            window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback) {\n      let currTime = new Date().getTime();\n      let timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      let id = window.setTimeout(function() {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n","/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\nexport const Utils = {\n\n  /**\n   * determine whether it is a `Array`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isArray: (function() {\n    const ks = _rt([]);\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n  /**\n   * determine whether it is a `Object`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isObject: (function() {\n    const ks = _rt({});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n  /**\n   * determine whether it is a `String`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isString: (function() {\n    const ks = _rt('s');\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n  /**\n   * determine whether it is a `Number`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isNumber: (function() {\n    const ks = _rt(1);\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: (function() {\n    const ks = _rt(function() {});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined(variable) {\n    return typeof variable === 'undefined';\n  },\n\n  /**\n   * determine whether it is a `Boolean`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isBoolean: (function() {\n    const ks = _rt(true);\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n};\n","import { EventDispatcher } from 'three';\nimport { Utils } from '../utils/Utils.js';\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nEventDispatcher.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = (ev) => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @param {Object} event event object, include more information\n * @return {this} this\n */\nEventDispatcher.prototype.emit = function(type, event) {\n  event.type = type;\n  this.dispatchEvent(event);\n  return this;\n};\n\n","import { Object3D } from 'three';\nimport { Utils } from '../utils/Utils';\n\n/**\n * whether displayObject is interactively\n */\nObject3D.prototype.interactive = false;\n\n/**\n * whether displayObject's children is interactively\n */\nObject3D.prototype.interactiveChildren = true;\n\n/**\n * whether displayObject had touchstart\n * @private\n */\nObject3D.prototype.started = false;\n\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  },\n});\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nObject3D.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nObject3D.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nObject3D.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = (ev) => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @param {Object} event event object, include more information\n * @return {this} this\n */\nObject3D.prototype.emit = function(type, event) {\n  event.type = type;\n  this.dispatchEvent(event);\n  return this;\n};\n\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\nObject3D.prototype.raycastTest = function(raycaster) {\n  const result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n","import { EventDispatcher } from 'three';\n\n/**\n * @extends EventDispatcher\n */\nclass Ticker extends EventDispatcher {\n  /**\n   *\n   */\n  constructor() {\n    super();\n    this.timer = null;\n    this.started = false;\n\n    /**\n     * 前一帧的时间标记\n     *\n     * @member {Number}\n     * @private\n     */\n    this.pt = 0;\n\n    /**\n     * 本次渲染经历的时间片段长度\n     *\n     * @member {Number}\n     * @private\n     */\n    this.snippet = 0;\n\n    this.start();\n  }\n\n  /**\n   * start\n   */\n  start() {\n    if (this.started) return;\n    const loop = () => {\n      this.timeline();\n      this.emit('tick', { snippet: this.snippet });\n      this.timer = RAF(loop);\n    };\n    loop();\n  }\n\n  /**\n   * stop\n   */\n  stop() {\n    CAF(this.timer);\n    this.started = false;\n  }\n\n  /**\n   * 时间轴部件\n   *\n   * @private\n   */\n  timeline() {\n    this.snippet = Date.now() - this.pt;\n    if (this.pt === 0 || this.snippet > 200) {\n      this.pt = Date.now();\n      this.snippet = Date.now() - this.pt;\n    }\n\n    this.pt += this.snippet;\n  }\n}\n\nexport default Ticker;\n","import { Vector2 } from 'three';\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\nclass InteractionData {\n  /**\n   * InteractionData constructor\n   */\n  constructor() {\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n    this.global = new Vector2();\n\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n    this.originalEvent = null;\n\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n    this.identifier = null;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n    this.isPrimary = false;\n\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n    this.button = 0;\n\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n    this.buttons = 0;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n    this.tiltX = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n    this.tiltY = 0;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n    this.pointerType = null;\n\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n    this.pressure = 0;\n\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n    this.rotationAngle = 0;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.twist = 0;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.tangentialPressure = 0;\n  }\n\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n  get pointerId() {\n    return this.identifier;\n  }\n\n  /**\n   * Copies properties from normalized event data.\n   *\n   * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n   * @private\n   */\n  _copyEvent(event) {\n    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n    // it with \"false\" on later events when our shim for it on touch events might not be\n    // accurate\n    if (event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.width = event.width;\n    this.height = event.height;\n    this.tiltX = event.tiltX;\n    this.tiltY = event.tiltY;\n    this.pointerType = event.pointerType;\n    this.pressure = event.pressure;\n    this.rotationAngle = event.rotationAngle;\n    this.twist = event.twist || 0;\n    this.tangentialPressure = event.tangentialPressure || 0;\n  }\n\n  /**\n   * Resets the data for pooling.\n   *\n   * @private\n   */\n  _reset() {\n    // isPrimary is the only property that we really need to reset - everything else is\n    // guaranteed to be overwritten\n    this.isPrimary = false;\n  }\n}\n\nexport default InteractionData;\n","/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\nclass InteractionEvent {\n  /**\n   * InteractionEvent constructor\n   */\n  constructor() {\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n    this.stopped = false;\n\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n    this.currentTarget = null;\n\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n    this.type = null;\n\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n    this.data = null;\n\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersect}\n     */\n    this.intersect = null;\n  }\n\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n  stopPropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Resets the event.\n   *\n   * @private\n   */\n  _reset() {\n    this.stopped = false;\n    this.currentTarget = null;\n    this.target = null;\n    this.intersect = null;\n  }\n}\n\nexport default InteractionEvent;\n","/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\nexport default class InteractionTrackingData {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  constructor(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n  _doSet(flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & (~flag);\n    }\n  }\n\n  /**\n   * Unique pointer id of the event\n   *\n   * @readonly\n   * @member {number}\n   */\n  get pointerId() {\n    return this._pointerId;\n  }\n\n  /**\n   * State of the tracking data, expressed as bit flags\n   *\n   * @member {number}\n   */\n  get flags() {\n    return this._flags;\n  }\n\n  /**\n   * Set the flags for the tracking data\n   *\n   * @param {number} flags - Flags to set\n   */\n  set flags(flags) {\n    this._flags = flags;\n  }\n\n  /**\n   * Is the tracked event inactive (not over or down)?\n   *\n   * @member {number}\n   */\n  get none() {\n    return this._flags === this.constructor.FLAGS.NONE;\n  }\n\n  /**\n   * Is the tracked event over the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get over() {\n    return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n  }\n\n  /**\n   * Set the over flag\n   *\n   * @param {boolean} yn - Is the event over?\n   */\n  set over(yn) {\n    this._doSet(this.constructor.FLAGS.OVER, yn);\n  }\n\n  /**\n   * Did the right mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get rightDown() {\n    return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the right down flag\n   *\n   * @param {boolean} yn - Is the right mouse button down?\n   */\n  set rightDown(yn) {\n    this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n  }\n\n  /**\n   * Did the left mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get leftDown() {\n    return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the left down flag\n   *\n   * @param {boolean} yn - Is the left mouse button down?\n   */\n  set leftDown(yn) {\n    this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n  }\n}\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2,\n});\n","import { EventDispatcher, Raycaster } from 'three';\n\nimport Ticker from '../utils/Ticker';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * base on [pixi.js](http://www.pixijs.com/)\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interactionManager = new InteractionManager(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on\n *\n * @class\n * @extends EventDispatcher\n */\nclass InteractionManager extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * whether auto-update for over event\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoUpdate = options.autoUpdate || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n    this.ticker = new Ticker();\n\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n    this.update = this.update.bind(this);\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    if (this.autoUpdate) this.ticker.addEventListener('tick', this.update);\n\n    // add click TODO:\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    if (this.autoUpdate) this.ticker.removeEventListener('tick', this.update);\n\n    // remove click TODO:\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        const intersect = displayObject.raycastTest(this.raycaster);\n        if (intersect) {\n          interactionEvent.intersect = intersect;\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n      if (isTouch && displayObject.started) {\n        displayObject.started = false;\n        this.triggerEvent(displayObject, 'touchend', interactionEvent);\n      }\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    this.raycaster.setFromCamera(interactionData.global, this.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionManager;\n"],"names":["lastTime","vendors","x","length","window","requestAnimationFrame","cancelAnimationFrame","callback","currTime","Date","getTime","timeToCall","Math","max","id","setTimeout","RAF","CAF","_rt","val","Object","prototype","toString","call","Utils","ks","variable","EventDispatcher","on","type","fn","isFunction","addEventListener","off","removeEventListener","once","cb","ev","emit","event","dispatchEvent","Object3D","interactive","interactiveChildren","started","defineProperty","_trackedPointers","raycastTest","raycaster","result","raycast","Ticker","timer","pt","snippet","start","loop","timeline","now","InteractionData","global","Vector2","target","originalEvent","identifier","isPrimary","button","buttons","width","height","tiltX","tiltY","pointerType","pressure","rotationAngle","twist","tangentialPressure","InteractionEvent","stopped","currentTarget","data","intersect","InteractionTrackingData","pointerId","_pointerId","_flags","FLAGS","NONE","flag","yn","flags","constructor","OVER","_doSet","RIGHT_DOWN","LEFT_DOWN","freeze","MOUSE_POINTER_ID","hitTestEvent","InteractionManager","renderer","scene","camera","options","autoPreventDefault","autoUpdate","interactionFrequency","mouse","set","activeInteractionData","interactionDataPool","eventData","interactionDOMElement","moveWhenInside","eventsAdded","mouseOverRenderer","supportsTouchEvents","supportsPointerEvents","PointerEvent","onClick","bind","processClick","onPointerUp","processPointerUp","onPointerCancel","processPointerCancel","onPointerDown","processPointerDown","onPointerMove","processPointerMove","onPointerOut","processPointerOverOut","onPointerOver","cursorStyles","currentCursorMode","cursor","Raycaster","ticker","update","_deltaTime","setTargetElement","domElement","globalPoint","root","processInteractive","element","removeEvents","addEvents","navigator","msPointerEnabled","style","document","didMove","k","hasOwnProperty","interactionData","interactionEvent","configureInteractionEventForDOMEvent","setCursorMode","mode","assign","displayObject","eventString","point","y","rect","parentElement","getBoundingClientRect","left","top","func","hitTest","visible","hit","interactiveParent","children","i","child","childHit","parent","events","normalizeToPointerData","isNormalized","preventDefault","getInteractionDataForPointerId","triggerEvent","eventLen","isRightButton","trackedPointers","rightDown","leftDown","cancelled","eventAppend","releaseInteractionDataForPointerId","onPointerComplete","undefined","trackingData","isTouch","isMouse","test","isDown","over","none","pop","_copyEvent","_reset","push","pointerEvent","mapPositionToPoint","clientX","clientY","setFromCamera","globalX","globalY","normalizedEvents","TouchEvent","li","changedTouches","touch","touches","radiusX","radiusY","force","layerX","offsetX","layerY","offsetY","MouseEvent","removeAllListeners","_tempPoint"],"mappings":"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"}