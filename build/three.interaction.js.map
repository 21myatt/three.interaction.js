{"version":3,"file":"three.interaction.js","sources":["../src/utils/Utils.js","../src/patch/EventDispatcher.js","../src/patch/Object3D.js","../src/interaction/InteractionData.js","../src/interaction/InteractionEvent.js","../src/interaction/InteractionTrackingData.js","../src/interaction/InteractionManager.js"],"sourcesContent":["/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\nexport const Utils = {\n\n  /**\n   * determine whether it is a `Array`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isArray: (function() {\n    const ks = _rt([]);\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n  /**\n   * determine whether it is a `Object`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isObject: (function() {\n    const ks = _rt({});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n  /**\n   * determine whether it is a `String`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isString: (function() {\n    const ks = _rt('s');\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n  /**\n   * determine whether it is a `Number`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isNumber: (function() {\n    const ks = _rt(1);\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: (function() {\n    const ks = _rt(function() {});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined(variable) {\n    return typeof variable === 'undefined';\n  },\n\n  /**\n   * determine whether it is a `Boolean`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isBoolean: (function() {\n    const ks = _rt(true);\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n};\n","import { EventDispatcher } from 'three';\nimport { Utils } from '../utils/Utils.js';\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nEventDispatcher.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = ev => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @param {Object} event event object, include more information\n * @return {this} this\n */\nEventDispatcher.prototype.emit = function(type, event) {\n  event.type = type;\n  this.dispatchEvent(event);\n  return this;\n};\n\n","import { Object3D } from 'three';\nimport { Utils } from '../utils/Utils';\n\n/**\n * whether displayObject is interactively\n */\nObject3D.prototype.interactive = false;\n\n/**\n * whether displayObject's children is interactively\n */\nObject3D.prototype.interactiveChildren = true;\n\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  },\n});\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nObject3D.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nObject3D.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nObject3D.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = ev => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @param {Object} event event object, include more information\n * @return {this} this\n */\nObject3D.prototype.emit = function(type, event) {\n  event.type = type;\n  this.dispatchEvent(event);\n  return this;\n};\n\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\nObject3D.prototype.raycastTest = function(raycaster) {\n  const result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n","import { Vector2 } from 'three';\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\nexport default class InteractionData {\n  /**\n   *\n   */\n  constructor() {\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n    this.global = new Vector2();\n\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n    this.originalEvent = null;\n\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n    this.identifier = null;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n    this.isPrimary = false;\n\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n    this.button = 0;\n\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n    this.buttons = 0;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n    this.tiltX = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n    this.tiltY = 0;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n    this.pointerType = null;\n\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n    this.pressure = 0;\n\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n    this.rotationAngle = 0;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.twist = 0;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.tangentialPressure = 0;\n  }\n\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n  get pointerId() {\n    return this.identifier;\n  }\n\n  /**\n   * Copies properties from normalized event data.\n   *\n   * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n   * @private\n   */\n  _copyEvent(event) {\n    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n    // it with \"false\" on later events when our shim for it on touch events might not be\n    // accurate\n    if (event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.width = event.width;\n    this.height = event.height;\n    this.tiltX = event.tiltX;\n    this.tiltY = event.tiltY;\n    this.pointerType = event.pointerType;\n    this.pressure = event.pressure;\n    this.rotationAngle = event.rotationAngle;\n    this.twist = event.twist || 0;\n    this.tangentialPressure = event.tangentialPressure || 0;\n  }\n\n  /**\n   * Resets the data for pooling.\n   *\n   * @private\n   */\n  _reset() {\n    // isPrimary is the only property that we really need to reset - everything else is\n    // guaranteed to be overwritten\n    this.isPrimary = false;\n  }\n}\n","/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\nexport default class InteractionEvent {\n  /**\n   *\n   */\n  constructor() {\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n    this.stopped = false;\n\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n    this.currentTarget = null;\n\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n    this.type = null;\n\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n    this.data = null;\n\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersect}\n     */\n    this.intersect = null;\n  }\n\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n  stopPropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Resets the event.\n   *\n   * @private\n   */\n  _reset() {\n    this.stopped = false;\n    this.currentTarget = null;\n    this.target = null;\n    this.intersect = null;\n  }\n}\n","/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\nexport default class InteractionTrackingData {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  constructor(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n  _doSet(flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & (~flag);\n    }\n  }\n\n  /**\n   * Unique pointer id of the event\n   *\n   * @readonly\n   * @member {number}\n   */\n  get pointerId() {\n    return this._pointerId;\n  }\n\n  /**\n   * State of the tracking data, expressed as bit flags\n   *\n   * @member {number}\n   */\n  get flags() {\n    return this._flags;\n  }\n\n  /**\n   * Set the flags for the tracking data\n   *\n   * @param {number} flags - Flags to set\n   */\n  set flags(flags) {\n    this._flags = flags;\n  }\n\n  /**\n   * Is the tracked event inactive (not over or down)?\n   *\n   * @member {number}\n   */\n  get none() {\n    return this._flags === this.constructor.FLAGS.NONE;\n  }\n\n  /**\n   * Is the tracked event over the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get over() {\n    return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n  }\n\n  /**\n   * Set the over flag\n   *\n   * @param {boolean} yn - Is the event over?\n   */\n  set over(yn) {\n    this._doSet(this.constructor.FLAGS.OVER, yn);\n  }\n\n  /**\n   * Did the right mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get rightDown() {\n    return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the right down flag\n   *\n   * @param {boolean} yn - Is the right mouse button down?\n   */\n  set rightDown(yn) {\n    this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n  }\n\n  /**\n   * Did the left mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get leftDown() {\n    return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the left down flag\n   *\n   * @param {boolean} yn - Is the left mouse button down?\n   */\n  set leftDown(yn) {\n    this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n  }\n}\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2,\n});\n","import { EventDispatcher, Raycaster } from 'three';\n\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n * base on `pixi.js`\n *\n * @class\n * @extends EventDispatcher\n */\nexport default class InteractionManager extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=true] - Should the manager automatically prevent default browser actions.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.moveWhenInside = false;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // core.ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.INTERACTION);\n    // TODO: shoule add update to tick\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // core.ticker.shared.remove(this.update, this);\n    // TODO: shoule remove update to tick\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update(deltaTime) {\n    this._deltaTime += deltaTime;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in fireEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  fireEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        const intersect = displayObject.raycastTest(this.raycaster);\n        if (intersect) {\n          interactionEvent.intersect = intersect;\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.fireEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.fireEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.fireEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.fireEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.fireEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.fireEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.fireEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent);\n        }\n      } else if (isDown) {\n        this.fireEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (hit) {\n      this.fireEvent(displayObject, 'pointerup', interactionEvent);\n      if (isTouch) this.fireEvent(displayObject, 'touchend', interactionEvent);\n\n      if (trackingData) {\n        this.fireEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.fireEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.fireEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.fireEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (!this.moveWhenInside || hit) {\n      this.fireEvent(displayObject, 'pointermove', interactionEvent);\n      if (isTouch) this.fireEvent(displayObject, 'touchmove', interactionEvent);\n      if (isMouse) this.fireEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.fireEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.fireEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.fireEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.fireEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    this.raycaster.setFromCamera(interactionData.global, this.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n"],"names":["_rt","val","Object","prototype","toString","call","Utils","ks","variable","EventDispatcher","on","type","fn","isFunction","addEventListener","off","removeEventListener","once","cb","ev","emit","event","dispatchEvent","Object3D","interactive","interactiveChildren","defineProperty","_trackedPointers","raycastTest","raycaster","result","raycast","length","InteractionData","global","Vector2","target","originalEvent","identifier","isPrimary","button","buttons","width","height","tiltX","tiltY","pointerType","pressure","rotationAngle","twist","tangentialPressure","InteractionEvent","stopped","currentTarget","data","intersect","InteractionTrackingData","pointerId","_pointerId","_flags","FLAGS","NONE","flag","yn","flags","constructor","OVER","_doSet","RIGHT_DOWN","LEFT_DOWN","freeze","MOUSE_POINTER_ID","hitTestEvent","InteractionManager","renderer","scene","camera","options","autoPreventDefault","undefined","interactionFrequency","mouse","set","activeInteractionData","interactionDataPool","eventData","interactionDOMElement","moveWhenInside","eventsAdded","mouseOverRenderer","supportsTouchEvents","window","supportsPointerEvents","PointerEvent","onPointerUp","bind","processPointerUp","onPointerCancel","processPointerCancel","onPointerDown","processPointerDown","onPointerMove","processPointerMove","onPointerOut","processPointerOverOut","onPointerOver","cursorStyles","currentCursorMode","cursor","Raycaster","setTargetElement","domElement","globalPoint","root","processInteractive","element","removeEvents","addEvents","navigator","msPointerEnabled","style","document","deltaTime","_deltaTime","didMove","k","hasOwnProperty","interactionData","interactionEvent","configureInteractionEventForDOMEvent","setCursorMode","mode","assign","displayObject","eventString","point","x","y","rect","parentElement","getBoundingClientRect","left","top","func","hitTest","visible","hit","interactiveParent","children","i","child","childHit","parent","events","normalizeToPointerData","isNormalized","preventDefault","eventLen","getInteractionDataForPointerId","isRightButton","id","trackedPointers","fireEvent","rightDown","leftDown","cancelled","eventAppend","releaseInteractionDataForPointerId","onPointerComplete","trackingData","isTouch","isMouse","test","isDown","over","none","pop","_copyEvent","_reset","push","pointerEvent","mapPositionToPoint","clientX","clientY","setFromCamera","globalX","globalY","normalizedEvents","TouchEvent","li","changedTouches","touch","touches","radiusX","radiusY","force","layerX","offsetX","layerY","offsetY","MouseEvent","removeAllListeners","_tempPoint"],"mappings":"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"}